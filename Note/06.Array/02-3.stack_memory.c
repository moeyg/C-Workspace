// Stack memory

// sizeof(values)는 values 배열이 차지하는 총 바이트 수를 반환

// 05.Operator - 01-2.sizeof.c 에서 배열의 사이즈를 함수 인자로 받을 경우 다른 값이 나왔는데,
// 그 이유는 sizeof() 매개변수로 들어온 배열의 총 바이트 수를 반환할 수 있으려면 그 배열의 모든 요소가 스택에 다 복사되어 전달돼야 하고 호출되는 함수는 스택에 복사된 모든 요소의 크기를 정확히 알아야 한다.
// 즉, 배열의 크기가 다를 경우마다 함수 호출 시, 스택 메모리 크기가 달라야 한다는 뜻인데 이것은 불가능하다.
// 함수는 호출자에 무관하게 딱 정해진 수와 크기의 매개변수가 들어온다는 가정으로 동작한다. 즉, 함수가 먼저 결정되고 호출자는 그 함수를 호출한다.

size_t get_char_array_size(char data[])
{
    return sizeof(*data);
}

int main(void)
{
    char char_array[42];

    // 배열의 크기를 42로 지정해도 컴파일 시에는 char_array[]와 동일하다.
    size_t size_array_by_func = get_char_array_size(char_array); // 4
    // 따라서 4를 반환한 이유는 배열의 시작 위치(주소)를 스택에 넣어주기 때문이다.
    // 포인터 char 데이터형의 크기 = 1 byte 이므로 sizeof() 시 1 byte가 나온 것

    return 0;
}

// 반복문을 이용해 배열의 값을 변경하면 원본 배열이 바뀐다.
// 스택 메모리에는 nums[5]의 요소인 0, 1, 2, 3, 4 가 차례로 쌓여 있다가,
// for문을 만나면 스택 메모리의 값이 0, 2, 4, 6, 8 로 원본 배열의 값이 바뀐다.
void foo(void)
{
    size_t index;
    int nums[5] = { 0, 1, 2, 3, 4 };

    for (index = 0; index < 5; ++index)
    {
        nums[index] *= 2;
    }
}

// 따라서 매개변수 배열의 길이는 알 수 없기 때문에 매크로를 사용해 쓸 수 있다.
// 배열의 요소 개수 구하는 방법
// 총 배열의 크기 / 첫 번째 요소 크기
const size_t variable = sizeof(values) / sizeof(values[0]);

// 배열 요소의 값 초기화
int array_1[4]; // 쓰레기값 존재
int array_2[4] = { 1, 2, 3, 4 }; // 모두 초기화 됨
int array_3[4] = { 1, 2 }; // 1, 2, 0, 0
int array_4[2] = { 1, 2, 3 }; // 배열의 크기에 넘어서는 값일 때는 컴파일 오류
int array_5[] = { 1, 2, 3 }; // 배열의 크기를 지정하지 않고 배열의 요소만 넣으면 컴파일러가 배열의 크기를 결정해 준다.

// 배열의 모든 값을 0으로 초기화 하는 가장 좋은 방법은
int array[10] = { 0, };

// 따라서 스택 메모리에 초기화 시키지 않으면 지역 변수를 모른 채 사용할 수 있고, 버퍼 오버플로 발생 가능 = Memory stomp