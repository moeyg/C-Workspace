// fgets()

char* fgets(char* str, int count, FILE* stream);

// 최대 count - 1 개의 문자열을 읽어서 str에 저장 (남은 1개에 '\0' 문자를 넣어준다.)
// fgets()는 '\n'을 만나거나 EOF를 만나거나 count - 1까지 읽어오면 반환을 한다.
// 즉, '\n'을 만나지 않아도 이 함수가 반환될 수 있다.
// str에 '\n'까지 넣어준다.
// -> 이유 : '\n'을 만나서 끝났을 때랑 아닐 때를 구분해야 하기 때문이다. '\0'이 들어와서 끝날 수가 있기 때문

// fgets() 매개 변수
// char* fgets(char* str, int count, FILE* stream)
// str : 입력받은 한 줄을 저장할 char 배열
// count : 한 번에 str에 쓰는 최대 문자 수, '\0' 문자를 포함하기 때문에 실제로 읽어오는 문자 수는 count - 1 개
// stream : 데이터를 읽어올 스트림, 키보드 입력을 읽어오고 싶다면 stdin을 넣어준다.

// FILE*
// 스트림을 제어하기 위해 필요한 정보를 담고 있는 자료형 -> 스트림을 제어하기 위해 필요한 모든 정보를 담고 있는 데이터(자료)형 (구조체)
// 스트림을 제어하기 위해 필요한 정보?
// 1. 파일 위치 표시자
// 2. 스트림이 사용하는 버퍼의 포인터
// 3. 읽기/쓰기 중에 발생한 오류를 기록하는 오류 표시자
// 4. 파일의 끝에 도달했음을 기록하는 EOF 지시자
// 입력 및 출력 스트림은 오직 FILE 포인터로만 접근 및 조작이 가능하다.
// file 뿐만 아니라 다른 스트림도 모두 표현이 가능하다.

// fgets() 반환값
// 성공 시, str 반환
// 실패 시, NULL 반환

#include <stdio.h>

#define LINE_LENGTH (10)

int main(void)
{
    char line[LINE_LENGTH];

    while (fgets(line, LINE_LENGTH, stdin) != NULL)
    {
        printf("%s", line);
    }
    // 아직 입력 스트림에 남아있는 문자들을 읽는다.
    // 읽는 중간에 '\n' 문자를 만나고 '\n' 문자까지의 문자열을 line에 넣는다.
    // 언제나 배열의 크기는 출분히 크게 잡아야 한다.

    // 예를 들어 "123456789abcd\n" 를 입력하면,
    // 123444456789\0 까지만 읽는다.

    return 0;
}

// fgets()에 쓸 버퍼는 초기화가 필요하지 않다.
// 읽기 전에 들어 있는 값은 쓰레기 값이지만, 버퍼에 넣을 때 알아서 처음부터 읽어주고 '\0' 문자도 넣어준다.

// 한 줄씩 읽는 방법이 유용한 경우
// 단어를 하나씩 읽는 것보단 한 줄씩 읽는 게 빠르다.
// CPU를 벗어나 외부 구성 요소로부터 무언가를 읽어올 때는 과부하가 걸릴 수 있기 때문에 한 번에 많이 읽어오는 게 더 빠르기 때문이다.
// 따라서 버퍼의 크기는 충분히 큰 게 좋다. 버퍼 오버플로는 없어야 한다.
// 안전한 데이터 입력을 받고 무한루프에 빠지는 일이 없이 데이터를 읽어올 때 한 줄씩 읽는 방법이 한 단어씩 읽는 방법보다 유용하다.